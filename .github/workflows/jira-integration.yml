name: Jira Integration

on:
  pull_request:
    types: [closed]
  push:
    branches: [custom-qa, custom, release]

jobs:
  update-jira:
    if: github.event.pull_request.merged == true || github.event_name == 'push'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract Jira ticket from commits
        id: extract-ticket
        run: |
          # Get commit messages from the PR or latest push
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            COMMITS=$(git log --pretty=format:"%s" ${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }})
          else
            COMMITS=$(git log --pretty=format:"%s" -1)
          fi
          
          echo "Commit messages:"
          echo "$COMMITS"
          
          # Extract Jira ticket keys (format: ABC-123, PROJ-456, etc.)
          JIRA_TICKETS=$(echo "$COMMITS" | grep -oE '[A-Z]{2,10}-[0-9]+' | sort -u || true)
          
          if [ -n "$JIRA_TICKETS" ]; then
            echo "Found Jira tickets: $JIRA_TICKETS"
            echo "tickets<<EOF" >> $GITHUB_OUTPUT
            echo "$JIRA_TICKETS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "No Jira tickets found in commit messages"
            echo "tickets=" >> $GITHUB_OUTPUT
          fi

      - name: Update Jira tickets
        if: steps.extract-ticket.outputs.tickets != ''
        env:
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          JIRA_USER_EMAIL: ${{ secrets.JIRA_USER_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
        run: |
          # Function to update Jira ticket
          update_jira_ticket() {
            local ticket_key=$1
            local transition_id=$2
            local comment=$3
            
            echo "Updating ticket: $ticket_key"
            
            # Get current ticket status
            response=$(curl -s -u "$JIRA_USER_EMAIL:$JIRA_API_TOKEN" \
              -H "Accept: application/json" \
              "$JIRA_BASE_URL/rest/api/3/issue/$ticket_key")
            
            if echo "$response" | jq -e '.key' > /dev/null; then
              echo "Ticket $ticket_key found"
              
              # Add comment about the merge
              curl -s -u "$JIRA_USER_EMAIL:$JIRA_API_TOKEN" \
                -X POST \
                -H "Accept: application/json" \
                -H "Content-Type: application/json" \
                "$JIRA_BASE_URL/rest/api/3/issue/$ticket_key/comment" \
                -d "{
                  \"body\": {
                    \"type\": \"doc\",
                    \"version\": 1,
                    \"content\": [
                      {
                        \"type\": \"paragraph\",
                        \"content\": [
                          {
                            \"type\": \"text\",
                            \"text\": \"$comment\"
                          }
                        ]
                      }
                    ]
                  }
                }"
              
              # Get available transitions
              transitions=$(curl -s -u "$JIRA_USER_EMAIL:$JIRA_API_TOKEN" \
                -H "Accept: application/json" \
                "$JIRA_BASE_URL/rest/api/3/issue/$ticket_key/transitions")
              
              echo "Available transitions:"
              echo "$transitions" | jq -r '.transitions[] | "\(.id): \(.name)"'
              
              # Determine target status based on branch
              TARGET_BRANCH="${{ github.ref_name }}"
              echo "Target branch: $TARGET_BRANCH"
              
              # Define multiple possible transition names for each branch
              case "$TARGET_BRANCH" in
                "custom-qa")
                  POSSIBLE_TRANSITIONS="Fixed in QA|QA|Testing|Test"
                  PREFERRED_STATUS="Fixed in QA"
                  ;;
                "custom")
                  POSSIBLE_TRANSITIONS="Fixed in UAT|UAT|User Acceptance|Acceptance"
                  PREFERRED_STATUS="Fixed in UAT"
                  ;;
                "release")
                  POSSIBLE_TRANSITIONS="Fixed in Stage|FIXED IN STAGE|Stage|Ready for Release|READY FOR RELEASE|Released|Deploy"
                  PREFERRED_STATUS="Fixed in Stage"
                  ;;
                *)
                  POSSIBLE_TRANSITIONS="Done|Resolved|Closed|Complete"
                  PREFERRED_STATUS="Done"
                  ;;
              esac
              
              echo "Looking for transitions matching: $POSSIBLE_TRANSITIONS"
              
              # Find transition using flexible matching
              target_transition=$(echo "$transitions" | jq -r --arg patterns "$POSSIBLE_TRANSITIONS" '
                .transitions[] | 
                select(.name | test($patterns; "i")) | 
                .id' | head -1)
              
              # Get the actual transition name that was found
              if [ -n "$target_transition" ]; then
                ACTUAL_STATUS=$(echo "$transitions" | jq -r --arg id "$target_transition" '
                  .transitions[] | 
                  select(.id == $id) | 
                  .name')
                echo "Found matching transition: $ACTUAL_STATUS (ID: $target_transition)"
                
                # Check if we got the preferred status
                if [ "$ACTUAL_STATUS" != "$PREFERRED_STATUS" ]; then
                  echo "‚ö†Ô∏è Note: Preferred status '$PREFERRED_STATUS' not available, using '$ACTUAL_STATUS'"
                  STATUS_NOTE="Note: Intended for '$PREFERRED_STATUS' status, but transitioned to '$ACTUAL_STATUS' (closest available)"
                fi
              else
                echo "No matching transitions found, will try first available transition"
                # Get first available transition as fallback
                target_transition=$(echo "$transitions" | jq -r '.transitions[0].id' 2>/dev/null)
                if [ -n "$target_transition" ] && [ "$target_transition" != "null" ]; then
                  ACTUAL_STATUS=$(echo "$transitions" | jq -r --arg id "$target_transition" '.transitions[] | select(.id == $id) | .name')
                  echo "Using fallback transition: $ACTUAL_STATUS (ID: $target_transition)"
                  STATUS_NOTE="Note: Intended for '$PREFERRED_STATUS' status, but used fallback transition '$ACTUAL_STATUS'"
                else
                  echo "No transitions available"
                fi
              fi
              
              if [ -n "$target_transition" ]; then
                echo "Transitioning ticket $ticket_key to '$ACTUAL_STATUS' (transition ID: $target_transition)"
                transition_result=$(curl -s -u "$JIRA_USER_EMAIL:$JIRA_API_TOKEN" \
                  -X POST \
                  -H "Accept: application/json" \
                  -H "Content-Type: application/json" \
                  "$JIRA_BASE_URL/rest/api/3/issue/$ticket_key/transitions" \
                  -d "{
                    \"transition\": {
                      \"id\": \"$target_transition\"
                    }
                  }")
                
                if [ -z "$transition_result" ] || [[ "$transition_result" != *"error"* ]]; then
                  echo "‚úÖ Ticket $ticket_key transitioned to '$ACTUAL_STATUS'"
                else
                  echo "‚ùå Transition failed: $transition_result"
                fi
              else
                echo "‚ö†Ô∏è No valid transitions available for ticket $ticket_key"
              fi
            else
              echo "‚ùå Ticket $ticket_key not found or access denied"
            fi
          }
          
          # Process each ticket
          while IFS= read -r ticket; do
            if [ -n "$ticket" ]; then
              PR_URL="${{ github.event.pull_request.html_url || github.event.head_commit.url }}"
              TARGET_BRANCH="${{ github.ref_name }}"
              
              # Create branch-specific comment
              case "$TARGET_BRANCH" in
                "custom-qa")
                  DEPLOYMENT_ENV="QA Environment"
                  ;;
                "custom")
                  DEPLOYMENT_ENV="UAT Environment"
                  ;;
                "release")
                  DEPLOYMENT_ENV="Stage Environment"
                  ;;
                *)
                  DEPLOYMENT_ENV="Production"
                  ;;
              esac
              
              COMMENT="üöÄ Code deployed to $DEPLOYMENT_ENV via GitHub PR: $PR_URL"
              if [ -n "$STATUS_NOTE" ]; then
                COMMENT="$COMMENT

$STATUS_NOTE"
              fi
              update_jira_ticket "$ticket" "" "$COMMENT"
            fi
          done <<< "${{ steps.extract-ticket.outputs.tickets }}"

      - name: Summary
        if: steps.extract-ticket.outputs.tickets != ''
        run: |
          TARGET_BRANCH="${{ github.ref_name }}"
          case "$TARGET_BRANCH" in
            "custom-qa")
              STATUS="Fixed in QA"
              ENV="QA Environment"
              ;;
            "custom")
              STATUS="Fixed in UAT"
              ENV="UAT Environment"
              ;;
            "release")
              STATUS="Fixed in Stage"
              ENV="Stage Environment"
              ;;
            *)
              STATUS="Done"
              ENV="Production"
              ;;
          esac
          
          echo "## üé´ Jira Integration Summary" >> $GITHUB_STEP_SUMMARY
          echo "**Target Branch:** $TARGET_BRANCH" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment:** $ENV" >> $GITHUB_STEP_SUMMARY
          echo "**Jira Status:** $STATUS" >> $GITHUB_STEP_SUMMARY
          echo "**Updated Tickets:** ${{ steps.extract-ticket.outputs.tickets }}" >> $GITHUB_STEP_SUMMARY
          echo "**PR/Commit:** ${{ github.event.pull_request.html_url || github.event.head_commit.url }}" >> $GITHUB_STEP_SUMMARY